1    Introduzione C++
Il concetto di grafi è fondamentale nell’ambito dell’informatica e dell’ingegneria del software, rappresentando una potente struttura dati per modellare relazioni tra og- getti. In questo progetto, ci concentreremo specificamente sui grafi orientati, in cui gli archi hanno una direzione definita, consentendo di rappresentare relazioni asimmetriche tra nodi.
Il nostro obiettivo è sviluppare un’implementazione efficiente di grafi orientati in C++, fornendo un’interfaccia intuitiva per la creazione, la modifica e l’analisi di tali strutture dati. A tal fine, utilizzeremo un approccio modulare, separando la definizione del grafo e le operazioni ad esso associate in un file header dedica- to, "grafoorientato.h", e implementando un programma principale "main.cpp" per illustrare l’utilizzo pratico di queste funzionalità.
Nel file "grafoorientato.h", definiremo le strutture dati e le funzioni necessarie per rappresentare e manipolare un grafo orientato. Questo include la definizione di nodi, archi e le operazioni fondamentali come l’inserimento di nodi e archi, la rimozione di nodi e archi, e l’attraversamento del grafo.
Nel file "main.cpp", realizzeremo un’applicazione di esempio che dimostra l’uti- lizzo delle funzionalità fornite dal nostro modulo di grafi orientati.

2    C++
Nel nostro sketch iniziale, ci siamo concentrati sulla chiarezza, sull’accessibilità e sull’efficienza. Lavorando in gruppo ci siamo accorti come programmare per rendere migliore l’esperienza dell’utente con l’applicazione, portandoci così a modificare la grafica o rimuovere e implementare funzionalità diverse rispetto all’inizio.
2.1    grafoorientato.h
Gestione delle eccezioni:
• nodeAlreadyExistsException: nodeAlreadyExistsException è un tipo di eccezione che viene lanciata nel caso in cui si tenti di aggiungere un nodo a un grafo orientato in C++, ma il nodo che si sta cercando di aggiungere esiste già nel grafo. In sostanza, indica un tentativo di duplicazione di nodi nel grafo, il che è considerato un errore poiché ogni nodo dovrebbe essere unico nel grafo.
• edgeAlreadyExistsException: edgeAlreadyExistsException è un’eccezione che viene lanciata quando si cerca di aggiungere un arco in un grafo orientato, ma questo arco esiste già nel grafo. In altre parole, indica un tentativo di aggiungere un collegamento tra due nodi che è già presente nel grafo. Questo può accadere, ad esempio, se si tenta di aggiungere un arco tra due nodi che già hanno un arco di connessione, violando così la regola che un grafo orientato non deve avere archi duplicati tra i suoi nodi.
• nodeDontExistsException: nodeDontExistsException è un’eccezione che viene lanciata quando si cerca di eseguire un’operazione su un nodo in un grafo orientato, ma il nodo specificato non esiste nel grafo. Essa indica inequivocabil- mente che il nodo cercato non è presente nel grafo al momento dell’operazione richiesta.
• edgeDontExistsException: edgeDontExistsException è un’eccezione che viene lanciata quando si tenta di eseguire un’operazione su un arco in un grafo orientato, ma l’arco specificato non esiste nel grafo. Questo indica in modo inequivocabile che l’arco cercato non è presente nel grafo al momento dell’operazione richiesta
La classe grafo rappresenta la struttura di base per un grafo orientato in C++. Questa classe è progettata per gestire i nodi e gli archi all’interno del grafo e for- nire funzionalità per manipolarli. La classe grafo include metodi per aggiungere e rimuovere nodi e archi, verificare l’esistenza di un nodo o un arco, nonché metodi per ottenere informazioni sul grafo, come il numero di nodi o archi presenti.
Variabili di grafo:
• typedef T idNode: La dichiarazione typedef T idNode; indica che idNode è un alias per il tipo T, il quale è utilizzato come identificatore dei nodi in un grafo orientato. Questo significa che il tipo T viene utilizzato per rappre- sentare univocamente ciascun nodo nel grafo. La scelta del tipo T dipende dalle esigenze specifiche dell’applicazione e potrebbe essere un tipo predefinito come int, std::string o qualsiasi altro tipo personalizzato definito dall’utente. Utilizzando questa dichiarazione, è possibile utilizzare idNode per riferirsi al tipo specificato (T) in modo più chiaro e conciso nel codice.
• typedef unsigned int size type: La dichiarazione typedef unsigned int size type; indica che ‘size type‘ è un alias per il tipo di dato ‘unsigned int‘, che viene utilizzato per rappresentare le dimensioni o le dimensioni di un insieme di elementi. Questo tipo di dato viene comunemente utilizzato per indicizzare gli elementi di una struttura dati, come un array o un vettore, e per rappresentare la dimensione di una struttura dati dinamica come una lista o un insieme. Utilizzando questa dichiarazione, è possibile utilizzare ‘size type‘ per riferirsi al tipo specificato (‘unsigned int‘) in modo più chiaro e conciso nel codice.
• typedef C comparator: La dichiarazione typedef C comparator; definisce un alias comparator per il tipo C, consentendo di utilizzare comparator come tipo per definire oggetti o funzioni che eseguono operazioni di confronto. Questo è utile quando si lavora con algoritmi o strutture dati che richiedono una funzione di confronto personalizzata, come ordinamento o ricerca.
• size type capacity: La dichiarazione size type capacity; indica che capacity è una variabile di tipo size type, che rappresenta il numero di nodi nel grafo. Questo tipo di variabile è spesso utilizzato per memorizzare informazioni sulle dimensioni o sul numero di elementi in una struttura dati. Utilizzando size type, si garantisce la portabilità del codice su diverse piattaforme, poiché il tipo size type è definito per adattarsi alla dimensione della memoria del sistema.
• idNode *setOfNodes: La dichiarazione idNode *setOfNodes; indica che setOfNodes è un puntatore a un array che contiene i nodi del grafo. Qui, idNode rappresenta il tipo di dato utilizzato come identificatore per i nodi del grafo. Quindi, setOfNodes è un puntatore che può essere utilizzato per accedere all’array di nodi del grafo.
• bool **adjacencyMatrix: La dichiarazione bool **adjacencyMatrix; indica che adjacencyMatrix è un puntatore a una matrice dinamica di tipo bool, che rappresenta la matrice di adiacenza del grafo. In una matrice di adiacenza, ogni riga e ogni colonna corrispondono a un nodo del grafo, e il valore in posizione (i, j) indica se esiste un arco diretto dal nodo i al nodo j.Utilizzando bool, ogni elemento della matrice può essere vero (1) se esiste un arco tra i nodi corrispondenti, altrimenti falso (0).
Oltre ai metodi fondamentali (che evito di riportare nella documentazione), i metodi utilizzati all0ilterno del progetto sono:
• getEdgesNum(): La funzione getEdgesNum calcola il numero totale di archi nel grafo. Essa itera su ogni elemento nella matrice di adiacenza e incrementa la variabile edgeCount ogni volta che incontra un valore diverso da zero. Infine, restituisce il conteggio totale degli archi trovati.
• getCapacity(): La funzione getCapacity() restituisce la capacità del grafo orientato. Essa restituisce il valore della variabile capacity, che rappresenta la dimensione massima del grafo. Questa funzione è di tipo size type, che è un tipo di dato definito nel tuo progetto.
• setCapacity(): La funzione setCapacity() imposta la capacità del grafo orien- tato con un nuovo valore. Prima di impostare la capacità, la funzione controlla se il nuovo valore newCapacity è maggiore o uguale a zero. Se è così, la capa- cità viene impostata al nuovo valore e viene stampato un messaggio a schermo per confermare il cambio di capacità. Se il nuovo valore è negativo, viene stampato un messaggio di errore sullo stream di errore std::cerr.
• const-iterator: La classe const-iterator è un iteratore costante che viene utilizzato per scorrere una sequenza di elementi di tipo T. Ecco una descrizione dettagliata dei suoi metodi:
– typedef std::forward-iterator-tag iterator-category:: Questo defi- nisce il tipo della categoria dell’iteratore come forward-iterator-tag, che indica che l’iteratore può essere utilizzato per scorrere in avanti su una sequenza.
– typedef  T  value-type:  Questo definisce il tipo degli elementi nella sequenza come T.
– typedef ptrdiff-t difference-type:  Questo definisce il tipo utilizzato per rappresentare la differenza tra due puntatori.
– typedef const T* pointer: Questo definisce il tipo di puntatore agli elementi nella sequenza come const T*, che indica che il puntatore è costante e non può essere utilizzato per modificare gli elementi.
– typedef const T reference: Questo definisce il tipo di riferimento agli elementi nella sequenza come const T, che indica che il riferimento è costante e non può essere utilizzato per modificare gli elementi.
– const-iterator():  Questo è il costruttore di default che inizializza il puntatore ptr a nullptr.
– const-iterator(const const-iterator other): Questo è il costruttore di copia che crea un nuovo iteratore costante che punta allo stesso elemento di other.
– const-iterator operator=(const const-iterator other): Questo è l’operatore di assegnazione che assegna il valore di other.ptr a ptr del- l’iteratore corrente e restituisce l’iteratore corrente per consentire l’asse- gnazione concatenata.
–    const-iterator():  Questo è il distruttore che non fa nulla in questo caso.
– reference operator*() const: Questo è l’operatore di dereferenziamen- to che restituisce il valore dell’elemento puntato da ptr.
– pointer operator->() const: Questo è l’operatore freccia che restitui- sce il puntatore all’elemento puntato da ptr.
– const-iterator operator++(int): Questo è l’operatore di iterazione post-incremento che crea un nuovo iteratore costante tmp che punta allo stesso elemento dell’iteratore corrente, quindi incrementa ptr per puntare all’elemento successivo e restituisce tmp.
– const-iterator operator++(): Questo è l’operatore di iterazione pre- incremento che incrementa ptr per puntare all’elemento successivo e re- stituisce l’iteratore corrente.
– bool operator==(const const-iterator other) const: Questo è l’o- peratore di uguaglianza che confronta se ptr dell’iteratore corrente è ugua- le a ptr di other e restituisce true se sono uguali, altrimenti restituisce false.
– bool operator!=(const const-iterator other) const: Questo è l’o- peratore di diversità che confronta se ptr dell’iteratore corrente è diverso da ptr di other e restituisce true se sono diversi, altrimenti restituisce false.
– const-iterator(const T* p): Questo è un costruttore privato utiliz- zato dalla classe grafo per creare un iteratore costante a partire da un puntatore p.
• getPrimoElemento(): La funzione getPrimoElemento() restituisce un ite- ratore costante che punta al primo elemento del set di nodi del grafo orienta- to. Questo iteratore viene creato utilizzando il costruttore della classe const iterator passando come parametro il setOfNodes.
• getUltimoElemento(): La funzione getUltimoElemento() restituisce un ite- ratore costante che rappresenta la fine del set di nodi del grafo orientato. Que- sto iteratore viene creato utilizzando il costruttore della classe const iterator passando come parametro setOfNodes + capacity.
• addNode(): La funzione addNode() aggiunge un nuovo nodo al grafo orien- tato.  Prima di aggiungere il nodo, la funzione controlla se il nodo esiste giànel grafo utilizzando la funzione existsNode().   Se il nodo non esiste, viene eseguita una serie di operazioni per aggiungere il nodo al grafo.
Se la capacità del grafo è zero, viene allocata dinamicamente una dimensione di memoria per setOfNodes e adjacencyMatrix pari a 1. Il nodo viene quindi inserito in setOfNodes e la capacità viene incrementata. Successivamente, viene allocata memoria per adjacencyMatrix e inizializzata con valori booleani. Se la capacità del grafo non è zero, viene allocata dinamicamente una nuova dimensione di memoria per setOfNodes e tmpArcs pari a capacity + 1. I va- lori di setOfNodes vengono copiati in setOfNodes, il nuovo nodo viene inserito in setOfNodes, la capacità viene incrementata e la memoria di setOfNodes viene liberata. Viene quindi allocata memoria per tmpArcs e i valori di adja- cencyMatrix vengono copiati in tmpArcs. Viene inizializzata una nuova riga e una nuova colonna in tmpArcs per il nuovo nodo. Infine, la memoria di adjacencyMatrix viene liberata e adjacencyMatrix viene puntato a tmpArcs. Se il nodo esiste già nel grafo, viene lanciata un’eccezione nodeAlreadyE- xistsException.
• removeNode(): La funzione removeNode() rimuove un nodo dal grafo orien- tato. Prima di rimuovere il nodo, la funzione controlla se il nodo esiste nel grafo utilizzando la funzione existsNode(). Se il nodo esiste, vengono eseguite una serie di operazioni per rimuovere il nodo dal grafo.
Se la capacità del grafo è 1, vengono deallocati i puntatori di adjacencyMatrix e setOfNodes, e la capacità viene decrementata di 1.
Se la capacità del grafo è maggiore di 1, viene determinata la posizione del nodo all’interno di setOfNodes utilizzando la funzione getNodePosition(). Vie- ne quindi allocata dinamicamente una nuova dimensione di memoria per - setOfNodes di dimensione capacity - 1, e i nodi esistenti vengono copiati in -setOfNodes, escludendo il nodo da rimuovere. Viene deallocata la memoria di setOfNodes e setOfNodes viene puntato a -setOfNodes.
Viene quindi allocata dinamicamente una nuova dimensione di memoria per tmpArcs di dimensione capacity, e vengono copiati i valori della matrice di adiacenza da adjacencyMatrix a tmpArcs, escludendo la riga e la colonna corrispondenti al nodo da rimuovere. Viene deallocata la memoria di adjacen- cyMatrix e adjacencyMatrix viene puntato a tmpArcs.
Se il nodo non esiste nel grafo, viene lanciata un’eccezione nodeDontExistsEx- ception.
• addEdge(): La funzione addEdge() aggiunge un arco tra due nodi nel grafo orientato. La funzione controlla se i nodi di partenza e arrivo esistono nel grafo utilizzando la funzione existsNode(). Se entrambi i nodi esistono e non esiste già un arco tra di essi, viene impostato il valore true nella matrice di adiacenza corrispondente a quella posizione.
Se uno dei nodi non esiste nel grafo, viene lanciata un’eccezione nodeDontE- xistsException.
Se esiste già un arco tra i due nodi, viene lanciata un’eccezione edgeAlreadyE- xistsException.
• removeEdge(): La funzione removeEdge() rimuove un arco tra due nodi nel grafo orientato. La funzione controlla se i nodi di partenza e arrivo esistono nel grafo utilizzando la funzione existsNode(), e se esiste un arco tra di essi utilizzando la funzione existsEdge(). Se tutti e tre i controlli sono verificati, viene impostato il valore false nella matrice di adiacenza corrispondente a quella posizione.
Se uno dei nodi non esiste nel grafo, viene lanciata un’eccezione nodeDontE- xistsException.
Se non esiste un arco tra i due nodi, viene lanciata un’eccezione edgeDontE- xistsException.
• clearMatrix(): La funzione clearMatrix() si occupa di liberare la memoria utilizzata dalla matrice di adiacenza e dall’array di nodi nel grafo orientato. Prima di liberare la memoria, viene effettuato un controllo per verificare se la matrice di adiacenza e l’array di nodi sono diversi da nullptr. Se entram- bi i puntatori non sono nullptr, viene eseguito un ciclo for per deallocare la memoria di ogni riga della matrice di adiacenza utilizzando l’operatore de- lete[]. Successivamente, viene deallocata la memoria dell’intera matrice di adiacenza utilizzando l’operatore delete[]. Infine, viene impostato il puntatore adjacencyMatrix a nullptr.
Viene quindi effettuato un controllo per verificare se l’array di nodi è diverso da nullptr. Se il puntatore non è nullptr, viene deallocata la memoria dell’array di nodi utilizzando l’operatore delete[]. Infine, viene impostato il puntatore setOfNodes a nullptr.
Infine, viene chiamata la funzione setCapacity(0) per impostare la capacità del grafo a 0.
• existsNode(): La funzione existsNode() controlla se un nodo con l’id speci- ficato esiste nel grafo orientato. La funzione utilizza un oggetto comparator per confrontare l’id del nodo con gli id presenti nell’array setOfNodes. Viene eseguito un ciclo for per scorrere gli elementi dell’array setOfNodes e confron- tare ciascuno di essi con l’id fornito. Se viene trovata una corrispondenza, la funzione restituisce true, altrimenti restituisce false.
• existsEdge():La funzione existsEdge() controlla se esiste un arco tra due nodi nel grafo orientato. La funzione utilizza la funzione existsNode() per verificare se entrambi i nodi di partenza e arrivo esistono nel grafo. Se entrambi i nodi esistono, vengono ottenute le posizioni dei nodi all’interno dell’array setOfNodes utilizzando la funzione getNodePosition(). Successivamente, viene restituito il valore corrispondente nella matrice di adiacenza utilizzando le posizioni dei nodi. Se esiste un arco tra i due nodi, la funzione restituisce true, altrimenti restituisce false.
• getNodePosition(): La funzione getNodePosition() restituisce la posizione di un nodo con l’id specificato all’interno dell’array setOfNodes nel grafo orien- tato. La funzione utilizza un oggetto comparator per confrontare l’id del nodo con gli id presenti nell’array setOfNodes. Viene eseguito un ciclo for per scor- rere gli elementi dell’array setOfNodes e confrontare ciascuno di essi con l’id fornito. Se viene trovata una corrispondenza, la funzione restituisce l’indice della posizione dell’elemento nell’array setOfNodes. Se non viene trovata una corrispondenza, la funzione restituisce -1 per indicare che l’id del nodo non è stato trovato nell’array.
• validateNodeValue(): La funzione validateNodeValue() controlla se il valore di un nodo è valido. La funzione accetta un intero come parametro e restituisce true se il valore è uguale a true o false, altrimenti restituisce false.
2.2    main.cpp
Il file main.cpp è responsabile dei test per verificare la corretta esecuzione delle funzioni del file grafoorientato.h; esso contiene le seguenti funzioni:
• test-nodi-int(): Una funzione di test chiamata test-nodi-int(). Essa testa varie funzionalità di una classe grafo<int, compare-int>. La funzione ini- zia creando un’istanza della classe grafo e poi procede a testare le seguenti operazioni:
Aggiunta di nodi utilizzando il metodo addNode() e verifica se i nodi esistono utilizzando il metodo existsNode().
Aggiunta di nodi duplicati e verifica se la capacità rimane la stessa. Aggiunta di archi utilizzando il metodo addEdge() e verifica se gli archi esi- stono utilizzando il metodo existsEdge().
Rimozione di archi utilizzando il metodo removeEdge() e verifica se gli archi vengono rimossi.
Rimozione di nodi utilizzando il metodo removeNode() e verifica se i nodi vengono rimossi.
La funzione testa anche l’operatore di assegnazione e il costruttore di copia della classe grafo, così come la funzionalità del const-iterator.
• test-nodi-double(): La funzione test-nodi-double() sembra essere una fun- zione di test per la classe grafo che lavora con valori di tipo double. La fun- zione esegue una serie di test svolti uguali alla funzione test-nodi-int() ma con variabili double, per verificare il corretto funzionamento dei metodi della classe.
• test-nodi-tipoSpeciale(): La funzione test-nodi-tipoSpeciale() sembra es- sere una funzione di test per la classe grafo che lavora con valori di tipo ti- poSpeciale. La funzione esegue una serie di test svolti uguali alla funzione test-nodi-int() ma con variabili di tipo tipoSpeciale, per verificare il corretto funzionamento dei metodi della classe.

